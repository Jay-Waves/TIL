# 1 变量

<br>

## 1.1 变量类型

### 数值

- 有符号整型: `i8`, `i16`, `i32`, `i64`, `i128`, `isize`
- 无符号类型: `u8`, `u16`, `u32`, `u64`, `u128`, `usize`

默认未声明对象为 `i32`, 有符号数以**补码**存储

### 浮点数

默认对象为 `f64`, 现代64位处理器对`f32`和`f64`处理性能基本相同.

浮点数以*IEEE-754*标准存储, `f64`为双精度浮点数, `f32`是单精度.

- 避免浮点数比较, 即需要注意浮点数底层存储格式限制
- 注意未定义结果 NaN(not a number), 可能由于除零等数学上未定义的操作导致. 使用 `is_nan()` 方法判断一个数据是否是 NaN.

### 字符

字符采用 Unicode统一字符编码集, 每个字符占用4字节. 字符只能用 `''` 符号, 字符串只能用 `""` 符号.

> 强调: unicode是统一的编码约定, utf-8和utf-16等是该编码的某种存储方式. unicode固定4bytes; 但utf-8是长度可变的, 压缩了存储开销.

### 布尔值 bool

只有 `true` 和 `false`, 布尔值占1字节内存.
显示声明方式: `let var: bool = false;`

### 单元类型 ()

是个占位符, `fn main` 无返回值的话, 默认返回这个.

<br>

## 1.2 变量操作

### 溢出检测

-  使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
-  如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
-  使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
-  使用 `saturating_*` 方法使值达到最小值或最大值

### 变量声明方式

类似python的写法 `let var: i32 = 10;`
或者
后缀 `let var = 22_i32`

### 序列

允许遍历数字和字符类型, `1..5` 不包括5, `1..=5` 包括5. `'a'..='z'`遍历连续字符.

***

# 2 函数与结构

### 语句与表达式

Rust函数体由一系列语句 (statement) 执行操作, 然后由表达式 (expression) 返回值. 

表达式**不包含分号**, 因此能返回一个值. 常见的语句块都是表达式, 如if语句块和函数.

示例:
```rust
fn my_fn(){
	let y = {
		let x = 3;
		x + 1
	}
	let z = if y%2 == 1 {"odd"} else {"even"} //if 语句块
}
```

## 2.1 函数基础

要点:
- 函数名和变量名使用*蛇形命名法*
- **函数位置随便放**, rust编译器不关心在哪里定义函数
- *每个函数参数都要标注类型*