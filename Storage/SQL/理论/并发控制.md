**并发控制保证[事务](数据恢复.md)的隔离性和一致性**

<table>
<tr>
	<th></th>
	<th colspan="2">X 锁</th>
	<th colspan="2">S 锁</th>
	<th colspan="3">一致性保证</th>
</tr>
<tr>
	<th></th>
	<th>操作结束释放</th>
	<th>事务结束释放</th>
	<th>操作结束释放</th>
	<th>事务结束释放</th>
	<th>不丢失修改</th>
	<th>不读脏数据</th>
	<th>可重复读</th>
</tr>
<tr>
	<td>一级封锁协议</th> <td></td> <td>Y</td> <td></td> <td></td> <td>Y</td> <td></td> <td></td>
</tr>
<tr>
	<td>一级封锁协议</th> <td></td> <td>Y</td> <td>Y</td> <td></td> <td>Y</td> <td>Y</td> <td></td>
</tr>
<tr>
	<td>一级封锁协议</th> <td></td> <td>Y</td> <td></td> <td>Y</td> <td>Y</td> <td>Y</td> <td>Y</td>
</tr>
</table>

## 死锁与活锁



### 两段锁协议

2PL
1. 扩展阶段: 对任何数据*读和写*之前, 事务先对其封锁.
2. 收缩阶段: 释放一个封锁后, 事务不再申请和获得任何其他锁.

遵循 2PL 协议并发执行的事务, 则其可串行化.

## 意向锁

加锁粒度树: 加锁粒度越细, 系统并发性越高, 但效率越低 (开销越大).

```
 database
|        \
关系R1     关系R2
|    \       |    \
元组...元组   元组...元组
```

如果对一个节点加意向锁, 说明该节点的下层节点正在被加锁. 意向锁 (intention lock) 可以提高数据对象加锁时系统的检查效率, 因为系统不用再向下层扫描. 引入意向锁后, 申请封锁自粒度树上而下进行, 释放封锁自下而上进行.

- 意向共享锁, Intent Share Lock, IS: 下层节点拟加S锁
- 意向排他锁, Intent Exclusive Lock, IX: 下层节点拟加X锁.
- 共享意向排他锁, Share Intent Exclusive Lock, SIX: 先加S锁, 再加IX锁.

锁相容矩阵:

| v 已获得锁 > 要加的锁 | S   | X   | IS  | IX  | SIX |
| --------------------- | --- | --- | --- | --- | --- |
| S                     | Y   | N   | Y   | N   | N   |
| X                     | N   | N   | N   | N   | N   |
| IS                    | Y   | N   | Y   | Y   | Y   |
| IX                    | N   | N   | Y   | Y   | N   |
| SIX                   | N   | N   | Y   | N   | N    |
